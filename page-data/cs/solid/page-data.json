{"componentChunkName":"component---src-templates-blog-template-js","path":"/cs/solid/","result":{"data":{"cur":{"id":"f4896346-c110-59f1-b775-7c43840bd969","html":"<h3 id=\"srp-single-responsiblity-principle---단일-책임-원칙\" style=\"position:relative;\"><a href=\"#srp-single-responsiblity-principle---%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"srp single responsiblity principle   단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>SRP (Single Responsiblity Principle) - 단일 책임 원칙</strong></h3>\n<ul>\n<li>하나의 클래스는 하나의 책임만 가져야 한다.</li>\n<li>어떤 변화 (요구 사항등의 변화)에 의해서 클래스를 변경해야하는 이유는 오직 하나여야 한다.</li>\n<li>나머지 4원칙의 기초가 되는 원칙으로 SRP만 잘 지키면 다른 책임의 변경으로 인한 연쇄 작용을 방지할 수 있다.</li>\n</ul>\n<h3 id=\"ocp-open-closed-principle---개방-폐쇄-원칙\" style=\"position:relative;\"><a href=\"#ocp-open-closed-principle---%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"ocp open closed principle   개방 폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>OCP (Open-Closed Principle) - 개방, 폐쇄 원칙</strong></h3>\n<ul>\n<li>SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫쳐있어야 한다.\n<ul>\n<li>변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 극대화 한다.</li>\n</ul>\n</li>\n<li>OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다.</li>\n<li>새로운 기능이 추가되는 경우, 기존에 제공하던 클래스 (또는 메서드)를 수정하는 것이 아니라 새로운 클래스 (또는 메서드)를 추가해서 기능을 확장한다.</li>\n</ul>\n<h3 id=\"lsp-the-liskov-subsitution-principle---리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#lsp-the-liskov-subsitution-principle---%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"lsp the liskov subsitution principle   리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>LSP (The Liskov Subsitution Principle) - 리스코프 치환 원칙</strong></h3>\n<ul>\n<li>서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다.\n<ul>\n<li>슈퍼 클래스가 들어갈 자리에 서브 클래스를 넣어도, 원래대로 잘 작동해야 한다.</li>\n</ul>\n</li>\n<li>상속의 오용을 방지하게 하는 원칙</li>\n<li>슈퍼 클래스와 서브 클래스의 동작이 일관성 있게 동작해야함.</li>\n</ul>\n<h3 id=\"isp-interface-segregation-principle---인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#isp-interface-segregation-principle---%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"isp interface segregation principle   인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>ISP (Interface Segregation Principle) - 인터페이스 분리 원칙</strong></h3>\n<ul>\n<li>한 클래스는 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다.\n<ul>\n<li>하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.</li>\n</ul>\n</li>\n<li>SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조함.</li>\n<li><code class=\"language-text\">UserService</code>, <code class=\"language-text\">BoardService</code> (X)</li>\n<li><code class=\"language-text\">UserCreateService</code>, <code class=\"language-text\">BoardCreateService</code> (O)</li>\n</ul>\n<h3 id=\"dip-dependency-inversion-principle---의존성-역전의-원칙\" style=\"position:relative;\"><a href=\"#dip-dependency-inversion-principle---%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84%EC%9D%98-%EC%9B%90%EC%B9%99\" aria-label=\"dip dependency inversion principle   의존성 역전의 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>DIP (Dependency Inversion Principle) - 의존성 역전의 원칙</strong></h3>\n<ul>\n<li>변화하기 쉬운 것, 자주 변화하는 것 보다 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라.</li>\n<li>고차원 모듈은 주로 변화하지 않음, 저 차원 모듈에 주로 자주 변화함</li>\n<li>구체적인 구현 클래스 보다 추상화된 인터페이스에 의존하라, 구체적이며 변동성이 크다면 절대로 이름을 언급하지 마라.</li>\n</ul>","excerpt":"SRP (Single Responsiblity Principle) - 단일 책임 원칙 하나의 클래스는 하나의 책임만 가져야 한다. 어떤 변화 (요구 사항등의 변화)에 의해서 클래스를 변경해야하는 이유는 오직 하나여야 한다. 나머지 4원칙의 기초가 되는 원칙으로 SRP만 잘 지키면 다른 책임의 변경으로 인한 연쇄 작용을 방지할 수 있다. OCP (Open-Closed Principle) - 개방, 폐쇄 원칙 SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫쳐있어야 한다. 변경을 위한 비용은 가능한 줄이고, 확장을 위한 비용은 극대화 한다. OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다. 새로운 기능이 추가되는 경우, 기존에 제공하던 클래스 (또는 메서드)를 수정하는 것이 아니라 새로운 클래스 (또는 메서드)를 추가해서 기능을 확장한다. LSP (The Liskov Subsitution Principle) - 리스코프 치환 원칙 서브 …","frontmatter":{"date":"April 07, 2024","title":"객체지향 5대 원칙 SOLID","categories":"CS","author":"yi","emoji":"🔮"},"fields":{"slug":"/cs/solid/"}},"next":null,"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yihoney.github.io","comments":{"utterances":{"repo":"yihoney/yihoney-blog"}}}}},"pageContext":{"slug":"/cs/solid/","nextSlug":"","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}