{"componentChunkName":"component---src-templates-blog-template-js","path":"/cs/solid/","result":{"data":{"cur":{"id":"f4896346-c110-59f1-b775-7c43840bd969","html":"<blockquote>\n<h2 id=\"solid-객체-지향-설계\" style=\"position:relative;\"><a href=\"#solid-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84\" aria-label=\"solid 객체 지향 설계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SOLID (객체 지향 설계)</h2>\n<p>시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용 가능</p>\n</blockquote>\n<h3 id=\"단일-책임-원칙-srp-single-responsiblity-principle\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99-srp-single-responsiblity-principle\" aria-label=\"단일 책임 원칙 srp single responsiblity principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 책임 원칙 (SRP; Single Responsiblity Principle)</h3>\n<ul>\n<li>한 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.</li>\n<li>어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다.</li>\n</ul>\n<h3 id=\"개방-폐쇄-원칙-ocp-open-closed-principle\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-ocp-open-closed-principle\" aria-label=\"개방 폐쇄 원칙 ocp open closed principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개방-폐쇄 원칙 (OCP; Open-Closed Principle)</h3>\n<ul>\n<li>SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫혀있어야 한다.</li>\n<li>OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다.</li>\n<li>새로운 기능이 추가되는 경우, 기존에 제공하던 클래스(또는 메서드)를 수정하는 것이 아니라 새로운 클래스(또는 메서드)를 추가해서 기능을 확장한다.</li>\n</ul>\n<h3 id=\"리스코프-치환-원칙-lsp-liskov-subsitution-principle\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-lsp-liskov-subsitution-principle\" aria-label=\"리스코프 치환 원칙 lsp liskov subsitution principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리스코프 치환 원칙 (LSP; Liskov Subsitution Principle)</h3>\n<ul>\n<li>서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다.</li>\n<li>슈퍼 클래스가 들어갈 자리에 서브 클래스를 넣어도, 원래대로 잘 작동해야 한다.</li>\n<li>상속의 오용을 방지하게 하는 원칙이다.</li>\n</ul>\n<h3 id=\"인터페이스-분리-원칙-isp-interface-segregation-principle\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-isp-interface-segregation-principle\" aria-label=\"인터페이스 분리 원칙 isp interface segregation principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 분리 원칙 (ISP; Interface Segregation Principle)</h3>\n<ul>\n<li>한 클래스는 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다.\n<ul>\n<li>하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.</li>\n</ul>\n</li>\n<li>SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조한다.</li>\n<li><code class=\"language-text\">UserService</code>, <code class=\"language-text\">BoardService</code> (X) -> <code class=\"language-text\">UserCreateService</code>, <code class=\"language-text\">BoardCreateService</code> (O)</li>\n</ul>\n<h3 id=\"의존관계-역전-원칙-dip-dependency-inversion-principle\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dip-dependency-inversion-principle\" aria-label=\"의존관계 역전 원칙 dip dependency inversion principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존관계 역전 원칙 (DIP; Dependency Inversion Principle)</h3>\n<ul>\n<li>소프트웨어 모듈들을 분리하는 특정 형식을 지칭</li>\n<li>상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 반전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.</li>\n<li>상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.</li>\n<li>추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li>\n</ul>\n<p>출처 | <a href=\"https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)\">wikipedia</a></p>","excerpt":"SOLID (객체 지향 설계) 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용 가능 단일 책임 원칙 (SRP; Single Responsiblity Principle) 한 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다. 어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다. 개방-폐쇄 원칙 (OCP; Open-Closed Principle) SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫혀있어야 한다. OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다. 새로운 기능이 추가되는 경우, 기존에 제공하던 클래스(또는 메서드)를 수정하는 것이 아니라 새로운 클래스(또는 메서드)를 추가해서 기능을 확장한다. 리스코프 치환 원칙 (LSP; Liskov Subsitution Principle) 서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다. 슈퍼 클래스가 들…","frontmatter":{"date":"April 07, 2024","title":"객체지향 5대 원칙 SOLID","categories":"CS","author":"yi","emoji":"🔮"},"fields":{"slug":"/cs/solid/"}},"next":null,"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yihoney.github.io","comments":{"utterances":{"repo":"yihoney/yihoney-blog"}}}}},"pageContext":{"slug":"/cs/solid/","nextSlug":"","prevSlug":""}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}