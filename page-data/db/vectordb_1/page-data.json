{"componentChunkName":"component---src-templates-blog-template-js","path":"/db/vectordb_1/","result":{"data":{"cur":{"id":"a787dce1-e87c-50a7-8dc8-be4126937306","html":"<h2 id=\"vectordb-기반-application-구조\" style=\"position:relative;\"><a href=\"#vectordb-%EA%B8%B0%EB%B0%98-application-%EA%B5%AC%EC%A1%B0\" aria-label=\"vectordb 기반 application 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VectorDB 기반 application 구조</h2>\n<p>VectorDB의 파이프라인을 간단히 정리하자면 다음과 같다. 우선, <code class=\"language-text\">자연어</code>(비정형 데이터)를 의미를 가진 형상(<code class=\"language-text\">Text Embedding</code>)인 embedding vector로 변환하는 과정(<code class=\"language-text\">Vector Embedding</code>)을 거친다. 이후에 embedding을 통해 변환한 vector들을 <code class=\"language-text\">Vector DB</code>에 저장하고, <code class=\"language-text\">Application</code>에서는 이를 사용 목적에 맞게 사용한다.</p>\n<h3 id=\"text-embedding-이란\" style=\"position:relative;\"><a href=\"#text-embedding-%EC%9D%B4%EB%9E%80\" aria-label=\"text embedding 이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Text Embedding 이란?</h3>\n<p>기존의 비정형 데이터 형태의 자연어 데이터를 n차원의 수치형 벡터로 표상화 시킨 데이터이다.\n단순히 텍스트 -> 숫자 매핑이 아니라, 해당 언어가 가지는 의미적 컨텍스트를 나타낸다.</p>","excerpt":"VectorDB 기반 application 구조 VectorDB의 파이프라인을 간단히 정리하자면 다음과 같다. 우선, (비정형 데이터)를 의미를 가진 형상()인 embedding vector로 변환하는 과정()을 거친다. 이후에 embedding을 통해 변환한 vector들을 에 저장하고, 에서는 이를 사용 목적에 맞게 사용한다. Text Embedding 이란? 기존의 비정형 데이터 형태의 자연어 데이터를 n차원의 수치형 벡터로 표상화 시킨 데이터이다.\n단순히 텍스트 -> 숫자 매핑이 아니라, 해당 언어가 가지는 의미적 컨텍스트를 나타낸다.","frontmatter":{"date":"April 14, 2024","title":"[#1] VectorDB","categories":"DB","author":"yi","emoji":"💬"},"fields":{"slug":"/db/vectordb_1/"}},"next":{"id":"ff5fe871-fdd8-5c28-9052-2d7905c71eef","html":"<br>\n<blockquote>\n<br>\n<p><strong>목차</strong> <br>\n<a href=\"#mysql\"><code class=\"language-text\">MySQL</code> vs <code class=\"language-text\">MongoDB</code></a> <br>\n<a href=\"#acid-%EB%AA%A8%EB%8D%B8-vs-base-%EB%AA%A8%EB%8D%B8\"><code class=\"language-text\">ACID</code> vs <code class=\"language-text\">BASE</code></a>\n<br></p>\n</blockquote>\n<br>\n<p>기존에 사용하던 RDBMS인 MySQL과 NoSQL인 mongoDB는 어떤 차이가 있는지에 대해 정리해보고자 한다.\n<br></p>\n<h2 id=\"mysql\" style=\"position:relative;\"><a href=\"#mysql\" aria-label=\"mysql permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL</h2>\n<ul>\n<li>Oracle Corporation에서 만든 Relational Database Management System 관계형 데이터베이스 관리 시스템(RDBMS)</li>\n<li>데이터베이스 액세스를 위해 structured query language(SQL)을 사용하여 테이블 형태로 데이터를 저장</li>\n<li>데이터에 접근할 때, <code class=\"language-text\">JOIN</code>을 통해 다수의 테이블을 병합</li>\n<li>데이터베이스 스키마를 미리 정의하고, 테이블에서 필드 사이의 관계를 제어하는 규칙을 설정</li>\n<li>ACID 기반의 트랜잭션으로 데이터의 일관성을 보장하고, 복잡한 트랜잭션 처리를 안전하게 수행할 수 있도록 지원</li>\n</ul>\n<br>\n<h2 id=\"mongodb\" style=\"position:relative;\"><a href=\"#mongodb\" aria-label=\"mongodb permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MongoDB</h2>\n<ul>\n<li>데이터를 JSON-like documents로 저장하는 NoSQL 데이터베이스</li>\n<li>document는 관계된 정보를 함께 저장하고 <code class=\"language-text\">MQL(MongoDB query language)</code>을 사용하여 접근</li>\n<li>document별로 필드는 다를 수 있으며 document가 self-describing하므로 시스템에 document의 구조를 따로 정의할 필요가 없음</li>\n<li>BASE 기반의 트랜잭션으로 ACID보다 느슨한 일관성 모델을 사용하며, 높은 가용성과 분산 시스템에 적합한 성능 제공</li>\n</ul>\n<br>\n<h3 id=\"acid-모델-vs-base-모델\" style=\"position:relative;\"><a href=\"#acid-%EB%AA%A8%EB%8D%B8-vs-base-%EB%AA%A8%EB%8D%B8\" aria-label=\"acid 모델 vs base 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ACID 모델 vs Base 모델</h3>\n<table>\n    <tr>\n        <th>속성</th>\n        <th>BASE</th>\n        <th>ACID</th>\n    </tr>\n    <tr>\n        <td>적용 분야</td>\n        <td>NOSQL</td>\n        <td>RDBMS</td>\n    </tr>\n    <tr>\n        <td>일관성 측면</td>\n        <td>약한 일관성</td>\n        <td>강한 일관성</td>\n    </tr>\n    <tr>\n        <td>중점사항</td>\n        <td>Availability</td>\n        <td>‘Commit’에 집중</td>\n    </tr>\n    <tr>\n        <td>시스템 측면</td>\n        <td>성능에 초점</td>\n        <td>엄격한 데이터관리</td>\n    </tr>\n    <tr>\n        <td>효율성</td>\n        <td>쿼리 디자인이 중요</td>\n        <td>테이블 디자인이 중요</td>\n    </tr>\n</table>\n<br>\n<h4>ACID 모델</h4>\n<ul>\n<li>Atomicity(원자성) : 트랜잭션과 관련된 작업들이 모두 수행되었는지 아니면, 모두 실행이 안되었는지를 보장하는 능력</li>\n<li>Consistency(일관성) : 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것</li>\n<li>Isolation(고립성) : 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것. 즉, 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미</li>\n<li>Durability (지속성) : DBMS가 사용자에게 트랜잭션 커밋(commit) 응답을 했을 경우, 설사 데이터베이스 객체에 대한 해당 변경 사항이 디스크에 반영(flush) 되기 전에 시스템 장애가 발생하였더라도 해당 트랜잭션의 커밋은 보장 되어야 한다는 속성</li>\n</ul>\n<br>\n<h4>Base 모델</h4>\n<ul>\n<li>Basically Available(기본적인 가용성): 다수의 실패에도 가용성을 보장, 다수의 스토리지에 복사본 저장 (주 서버가 안되더라도 백업 서버는 동작한다)</li>\n<li>Soft state(소프트 상태): 저장소는 쓰기 일관성이 있을 필요가 없으며 서로 다른 복제본이 항상 상호 일관성이 있을 필요도 없음</li>\n<li>Eventual consistency(최종 일관성): 일시적으로 일관성이 깨지는 상태가 되어도 일정시간 후에는 일관성이 있는 상태가 되는 성질</li>\n</ul>\n<br>","frontmatter":{"date":"April 12, 2024","title":"MySQL vs mongoDB","categories":"VS","author":"yi","emoji":"🆚"},"fields":{"slug":"/vs/mysql_mongodb/"}},"prev":{"id":"25293bb8-c67c-57e2-ac66-8529092c0c98","html":"<p>chatGPT는 학습한 데이터를 기반으로 질문에 가장 근접한 답변을 내놓지만, 이에 대한 진위를 매번 정확하게 확인하지 못하기 때문에 <code class=\"language-text\">할루시네이션(Hallucination)</code> 현상이 발생하기도 한다. 할루시네이션이란 훈련된 데이터나 현실에 근거하지 않은 출력을 생성하는 경우를 말한다. 여기에는 잘못된 주장, 존재하지 않는 사실 생성, 처리하는 정보의 맥락이나 의미를 오해하거나 잘못 표현하는 것이 포함되기도 한다. (출처 : <a href=\"https://www.lecturernews.com\">한국강사신문</a>)</p>\n<p>이러한 문제를 극복하고 답변의 정확을 제고하기 위해선 질문에 대한 답변을 제공하기 전에 인터넷이나 믿을만한 소스에서 검색하고 찾아낸 후에 그것을 기반으로 답변을 하면된다.</p>\n<p>이 아이디어를 기반으로 한 구조가 <code class=\"language-text\">RAG(Retrieval Augmented Generation)</code>이다.\n실행 순서는 다음과 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 59.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAQAF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3WBmP//EABcQAQEBAQAAAAAAAAAAAAAAAAEQABH/2gAIAQEAAQUCXlcz/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGxABAAEFAQAAAAAAAAAAAAAAASEAEBExQXH/2gAIAQEAAT8hxhws8sEbrj2jG23/2gAMAwEAAgADAAAAEBPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAQEBAAMBAAAAAAAAAAAAAREAITFBYXH/2gAIAQEAAT8QaRmGLPuB6dnmuiCuZz9A1JhfY9w0Hf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"rag+llm\"\n        title=\"rag+llm\"\n        src=\"/static/7869f6fadd77c5ac2d6df10a6a1482b7/80e3c/jumpstart-fm-rag.jpg\"\n        srcset=\"/static/7869f6fadd77c5ac2d6df10a6a1482b7/4ec73/jumpstart-fm-rag.jpg 180w,\n/static/7869f6fadd77c5ac2d6df10a6a1482b7/158ba/jumpstart-fm-rag.jpg 360w,\n/static/7869f6fadd77c5ac2d6df10a6a1482b7/80e3c/jumpstart-fm-rag.jpg 720w,\n/static/7869f6fadd77c5ac2d6df10a6a1482b7/9b60a/jumpstart-fm-rag.jpg 898w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ol>\n<li>\n<p>Prompt + Query: 서비스를 사용하는 사용자의 질문과 그 질문을 어떤식으로 받아들일지에 대해 개발자나 구성하는 사람이 미리 짜놓은 LLM(Large Language Model) 프롬프트</p>\n</li>\n<li>\n<p>Query: 해당 유저가 검색</p>\n</li>\n<li>\n<p>검색 결과로 나온 유관 정보 몇 가지가 추출</p>\n</li>\n<li>\n<p>3번의 정보와 1번의 유저의 오리지널 질문을 같이 LLM(chat completion model)에 input으로써 넣게 되면 해당 질문과 추출된 context 정보를 토대로 최종적인 답변을 생성</p>\n</li>\n</ol>\n<p>검색 성능에 영향을 미치는 구간은 1번 ~ 5번이다. 하지만, 1번 ~ 3번에 focus를 실어야하는 이유는 4번과 5번에 우리가 개입할 수 있는 부분이 한정적이기 때문이다. 4번은 input이 정확하다면 최종 output도 정확하다. 또한, 답변의 형식을 결정하는 역할을 하는 게 크다. 5번은 LLM 모델의 성능에 영향을 받으므로, 우리는 전반부에 포커싱 함으로써 최종 답변의 퀄리티를 향상시킬 수 있다.</p>","frontmatter":{"date":"April 14, 2024","title":"[#2] 챗봇 설계하기","categories":"PJT","author":"yi","emoji":"💬"},"fields":{"slug":"/pjt/diary_0413/"}},"site":{"siteMetadata":{"siteUrl":"https://yihoney.github.io","comments":{"utterances":{"repo":"yihoney/yihoney-blog"}}}}},"pageContext":{"slug":"/db/vectordb_1/","nextSlug":"/vs/mysql_mongodb/","prevSlug":"/pjt/diary_0413/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}