{"componentChunkName":"component---src-templates-blog-template-js","path":"/pjt/diary_0412/","result":{"data":{"cur":{"id":"b72bdde9-ac23-5a48-9ef5-a94545156e6d","html":"<h2 id=\"들어가기에-앞서\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0%EC%97%90-%EC%95%9E%EC%84%9C\" aria-label=\"들어가기에 앞서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기에 앞서</h2>\n<blockquote>\n<br>\n<p>프로젝트의 <strong>기획 배경</strong>은 다음과 같다.</p>\n<ol>\n<li>\n<p>기존 사이트의 직관적이지 못한 UI</p>\n</li>\n<li>\n<p>가장 인기 있는 영상 파악의 어려움</p>\n</li>\n<li>\n<p>나에게 적합한 지, 역할(직무)별로 적합한 지 알기 어려움</p>\n</li>\n<li>\n<p>대부분이 영어로 되어 있어, 제목 또는 소개를 통해 컨텐츠가 어떤 내용을 내포하는지 알기 어려움</p>\n</li>\n<li>\n<p>컨텐츠 이용 혹은 영상을 들으며 생기는 질문을 실시간으로 대응해줄 수 있는 시스템의 부재</p>\n</li>\n</ol>\n<p>기획 배경을 바탕으로 우리 팀은 직관적인 페이지로 사용자들의 접근성 낮추고, 일회성 학습이 아닌, 동기를 부여하여 사이트를 계속 방문 하게끔 하는 학습 플랫폼을 기획하게 되었다.</p>\n<p>이 목표를 위해 우리 팀은 다음과 같은 <strong>기능</strong>을 제공하기로 하였다.</p>\n<ol>\n<li>현재 내 상황에 맞춘 <code class=\"language-text\">컨텐츠 추천 챗봇</code></li>\n<li>실시간으로 궁금증을 해결할 수 있는 <code class=\"language-text\">QnA 챗봇</code></li>\n<li>강의 검색 시 오타 교정 및 자동완성 기능을 통한 <code class=\"language-text\">간편 강의 검색</code></li>\n<li>QNA, 강의 소개, 서비스 소개 DB를 연동한 RAG 시스템으로 <code class=\"language-text\">구체적이고 정확한 답변 제공</code></li>\n<li>로드맵 및 강의 현황 대시보드 기능으로 <code class=\"language-text\">학습 지속성 향상</code></li>\n</ol>\n <br>\n</blockquote>\n<br>\n<h2 id=\"mongodb를-도입해보자꾸나\" style=\"position:relative;\"><a href=\"#mongodb%EB%A5%BC-%EB%8F%84%EC%9E%85%ED%95%B4%EB%B3%B4%EC%9E%90%EA%BE%B8%EB%82%98\" aria-label=\"mongodb를 도입해보자꾸나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mongoDB를 도입해보자꾸나</h2>\n<p>우리 서비스는 크롤링 한 강의 데이터와 FAQ 데이터, 사용자가 챗봇 서비스 이용 시 입력했던 채팅 기록 등을 저장해야 했다. 우리팀은 각 도메인마다의 다양한 데이터 성격을 고려해 기존에 사용해본 경험이 있는 MySQL, Redis 외에 추가적으로 mongoDB를 도입하기로 하였다. <br></p>\n<h4> 여기서 mongoDB란? </h4>\n<ul>\n<li>mongoDB란 document 지향적인 데이터베이스이다. document는 아래와 그림과 같이 field와 value 쌍으로 구성된 데이터 구조이다. field의 vaule에는 다른 document나 document 배열 혹은 배열을 저장하는 것도 가능하다.</li>\n<li>mongoDB는 스키마를 고정하지 않은 형태(Schema-less 구조)이다. 이러한 특징으로 필드 추가 및 제거가 간편하고, 분산 확장이 간단하다.</li>\n</ul>\n<p>참고 링크 : <a href=\"https://www.mongodb.com/docs/manual/introduction/#document-database\">mongoDB 공식문서</a> | <a href=\"\">mongoDB vs Redis</a>\n<br></p>\n<p>MongoDB를 도입한 이유는 강의 데이터가 일관적이지 않기 때문이다.\n요약된 정보만 제공하는 강의가 있고, 활동이나 목표 등 추가적인 정보를 제공하는 강의가 존재한다. 어떤 강의는 보유하고 있는 데이터를 다른 특정 강의는 가지고 있지 않을 수 있는데, 이럴 경우 데이터에 대한 관리가 힘들 뿐더러 null 데이터에 대한 여러 검증 작업이 필요할 것이다. 따라서, MongoDB를 도입해 <strong>각 document마다 다른 field를 가지고 있을 수 있도록</strong> 하였다.\n<br></p>\n<!-- 또한, 우리 서비스는 실시간 문의사항 대응과 사용자 맞춤 컨텐츠 추천 서비스를 챗봇으로 제공하기로 했다. 더욱 구체적이고 정확한 답변을 위해 채팅 내역을 영구 보관하고 이를 챗봇에 활용하는데, 이 과정에서 데이터 읽기 작업과 쓰기 작업이 빈번히 일어난다. \n\n참고 링크 : [] -->","excerpt":"들어가기에 앞서 프로젝트의 기획 배경은 다음과 같다. 기존 사이트의 직관적이지 못한 UI 가장 인기 있는 영상 파악의 어려움 나에게 적합한 지, 역할(직무)별로 적합한 지 알기 어려움 대부분이 영어로 되어 있어, 제목 또는 소개를 통해 컨텐츠가 어떤 내용을 내포하는지 알기 어려움 컨텐츠 이용 혹은 영상을 들으며 생기는 질문을 실시간으로 대응해줄 수 있는 시스템의 부재 기획 배경을 바탕으로 우리 팀은 직관적인 페이지로 사용자들의 접근성 낮추고, 일회성 학습이 아닌, 동기를 부여하여 사이트를 계속 방문 하게끔 하는 학습 플랫폼을 기획하게 되었다. 이 목표를 위해 우리 팀은 다음과 같은 기능을 제공하기로 하였다. 현재 내 상황에 맞춘  실시간으로 궁금증을 해결할 수 있는  강의 검색 시 오타 교정 및 자동완성 기능을 통한  QNA, 강의 소개, 서비스 소개 DB를 연동한 RAG 시스템으로  로드맵 및 강의 현황 대시보드 기능으로  mongoDB를 도입해보자꾸나 우리 서비스는 크롤링 한 …","frontmatter":{"date":"April 12, 2024","title":"[#1] mongoDB 도입기","categories":"PJT","author":"yi","emoji":"💬"},"fields":{"slug":"/pjt/diary_0412/"}},"next":{"id":"f4896346-c110-59f1-b775-7c43840bd969","html":"<blockquote>\n<h2 id=\"solid-객체-지향-설계\" style=\"position:relative;\"><a href=\"#solid-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84\" aria-label=\"solid 객체 지향 설계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SOLID (객체 지향 설계)</h2>\n<p>시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용 가능</p>\n</blockquote>\n<h3 id=\"단일-책임-원칙-srp-single-responsiblity-principle\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99-srp-single-responsiblity-principle\" aria-label=\"단일 책임 원칙 srp single responsiblity principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 책임 원칙 (SRP; Single Responsiblity Principle)</h3>\n<ul>\n<li>한 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.</li>\n<li>어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다.</li>\n</ul>\n<h3 id=\"개방-폐쇄-원칙-ocp-open-closed-principle\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-ocp-open-closed-principle\" aria-label=\"개방 폐쇄 원칙 ocp open closed principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개방-폐쇄 원칙 (OCP; Open-Closed Principle)</h3>\n<ul>\n<li>SW의 구성 요소 (모듈, 컴포넌트, 클래스, 메서드)는 확장에는 열려있고 변경에는 닫혀있어야 한다.</li>\n<li>OCP를 가능하게 하는 중요 매커니즘은 추상화와 다형성이다.</li>\n<li>새로운 기능이 추가되는 경우, 기존에 제공하던 클래스(또는 메서드)를 수정하는 것이 아니라 새로운 클래스(또는 메서드)를 추가해서 기능을 확장한다.</li>\n</ul>\n<h3 id=\"리스코프-치환-원칙-lsp-liskov-subsitution-principle\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-lsp-liskov-subsitution-principle\" aria-label=\"리스코프 치환 원칙 lsp liskov subsitution principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리스코프 치환 원칙 (LSP; Liskov Subsitution Principle)</h3>\n<ul>\n<li>서브 클래스는 언제나 슈퍼 클래스를 대체할 수 있어야 한다.</li>\n<li>슈퍼 클래스가 들어갈 자리에 서브 클래스를 넣어도, 원래대로 잘 작동해야 한다.</li>\n<li>상속의 오용을 방지하게 하는 원칙이다.</li>\n</ul>\n<h3 id=\"인터페이스-분리-원칙-isp-interface-segregation-principle\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-isp-interface-segregation-principle\" aria-label=\"인터페이스 분리 원칙 isp interface segregation principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 분리 원칙 (ISP; Interface Segregation Principle)</h3>\n<ul>\n<li>한 클래스는 자신이 사용하지 않는 인터페이스의 메서드에 의존하지 않아야 한다.\n<ul>\n<li>하나의 일반적인 인터페이스 보다는, 여러 개의 구체적인 인터페이스가 낫다.</li>\n</ul>\n</li>\n<li>SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조한다.</li>\n<li><code class=\"language-text\">UserService</code>, <code class=\"language-text\">BoardService</code> (X) -> <code class=\"language-text\">UserCreateService</code>, <code class=\"language-text\">BoardCreateService</code> (O)</li>\n</ul>\n<h3 id=\"의존관계-역전-원칙-dip-dependency-inversion-principle\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dip-dependency-inversion-principle\" aria-label=\"의존관계 역전 원칙 dip dependency inversion principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존관계 역전 원칙 (DIP; Dependency Inversion Principle)</h3>\n<ul>\n<li>소프트웨어 모듈들을 분리하는 특정 형식을 지칭</li>\n<li>상위 계층이 하위 계층에 의존하는 전통적인 의존관계를 반전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.</li>\n<li>상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.</li>\n<li>추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li>\n</ul>\n<p>출처 | <a href=\"https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)\">wikipedia</a></p>","frontmatter":{"date":"April 07, 2024","title":"객체지향 5대 원칙 SOLID","categories":"CS","author":"yi","emoji":"📔"},"fields":{"slug":"/cs/solid/"}},"prev":{"id":"1fc66c81-a6b9-5c47-9758-c8551c5c0aea","html":"<p>mongoDB에 대해 알아보던 도중 같은 noSQL인 Redis와의 차이는 무엇일지 궁금해 찾아본 내용들을 정리해보고자 한다.</p>\n<p>차이점을 표로 간단히 정리하자면 다음과 같다.</p>\n<table>\n    <tr>\n        <th>구분</th>\n        <th>Redis</th>\n        <th>MongoDB</th>\n    </tr>\n        <tr>\n        <td>저장소</td>\n        <td>메모리 저장</td>\n        <td>디스크 저장</td>\n    </tr>\n    <tr>\n        <td>데이터 구조</td>\n        <td>key-value <br>\n        - key: 문자열 <br>\n        - value: 문자열 및 List, Set, Bitmap, Hash와 같은 여러 데이터 구조\n        </td>\n        <td>BSON(Binary JSON) <br>\n        - 문자열, 부울, 숫자, 배열, 객체, 날짜 등 다양한 데이터 유형 지원\n        </td>\n    </tr>\n    <tr>\n        <td>확장성</td>\n        <td>수평적 확장 (샤딩)</td>\n        <td>수평적 확장 (샤딩), 복제 세트를 이용한 고가용성 제공</td>\n    </tr>\n    <tr>\n        <td>지원 쿼리</td>\n        <td>기본적인 Key-Value 연산 및 데이터 구조별 복잡한 연산 지원</td>\n        <td>다양한 쿼리 연산, 인덱싱, 집계 파이프라인 지원</td>\n    </tr>\n    <tr>\n        <td>데이터 유지</td>\n        <td>주로 캐싱에 사용, 영속성을 위한 RDB/AOF 옵션 제공</td>\n        <td>데이터 영속화</td>\n    </tr>\n    <tr>\n        <td>성능</td>\n        <td>메모리 기반으로 고속의 데이터 처리 가능</td>\n        <td>메모리 매핑을 이용한 빠른 데이터 처리 가능</td>\n    </tr>\n</table>\n<p><strong>mongoDB</strong>는 메모리맵 형태의 파일 엔진 db이기 때문에 <em><strong>메모리에 의존적</strong></em>이라 메모리 크기가 성능을 좌우하며 메모리를 넘어서는 경우 성능이 급격히 저하된다.</p>\n<br>\n<p><strong>참고</strong>\n<a href=\"https://www.mongodb.com/compare/mongodb-vs-redis\">mongoDB 공식 문서 - mongoDB vs Redis</a></p>\n<br>","frontmatter":{"date":"April 12, 2024","title":"mongoDB vs Redis","categories":"VS","author":"yi","emoji":"🆚"},"fields":{"slug":"/vs/Redis_mongoDB/"}},"site":{"siteMetadata":{"siteUrl":"https://yihoney.github.io","comments":{"utterances":{"repo":"yihoney/yihoney-blog"}}}}},"pageContext":{"slug":"/pjt/diary_0412/","nextSlug":"/cs/solid/","prevSlug":"/vs/Redis_mongoDB/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}